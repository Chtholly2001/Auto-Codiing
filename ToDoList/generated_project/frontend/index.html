<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToDoList - å¾…åŠäº‹é¡¹ç®¡ç†</title>
    <link rel="stylesheet" href="style.css">
</head>
<body data-theme="light">
    <div class="container">
        <header class="header">
            <h1>ğŸ“ æˆ‘çš„å¾…åŠæ¸…å•</h1>
            <p>é«˜æ•ˆç®¡ç†æ‚¨çš„æ—¥å¸¸ä»»åŠ¡</p>
        </header>

        <main class="main">
            <!-- ä¸»é¢˜åˆ‡æ¢ -->
            <div class="theme-switcher">
                <button id="themeToggle" class="btn-secondary">ğŸŒ™ åˆ‡æ¢æš—è‰²</button>
            </div>

            <!-- æ·»åŠ ä»»åŠ¡åŒºåŸŸ -->
            <div class="add-task-section">
                <input 
                    type="text" 
                    id="taskInput" 
                    placeholder="è¯·è¾“å…¥æ–°çš„å¾…åŠäº‹é¡¹..." 
                    maxlength="100"
                >
                <select id="taskPriority">
                    <option value="low">ä½ä¼˜å…ˆçº§</option>
                    <option value="medium" selected>ä¸­ä¼˜å…ˆçº§</option>
                    <option value="high">é«˜ä¼˜å…ˆçº§</option>
                </select>
                <input type="date" id="taskDueDate">
                <input type="text" id="taskTags" placeholder="æ ‡ç­¾ (ç”¨é€—å·åˆ†éš”)">
                <button id="addTaskBtn" class="btn-primary">æ·»åŠ ä»»åŠ¡</button>
            </div>

            <!-- ä»»åŠ¡ç­›é€‰ -->
            <div class="task-filters">
                <select id="filterStatus">
                    <option value="all">æ‰€æœ‰çŠ¶æ€</option>
                    <option value="pending">å¾…å®Œæˆ</option>
                    <option value="completed">å·²å®Œæˆ</option>
                </select>
                <select id="filterPriority">
                    <option value="all">æ‰€æœ‰ä¼˜å…ˆçº§</option>
                    <option value="high">é«˜ä¼˜å…ˆçº§</option>
                    <option value="medium">ä¸­ä¼˜å…ˆçº§</option>
                    <option value="low">ä½ä¼˜å…ˆçº§</option>
                </select>
                <input type="text" id="searchInput" placeholder="æœç´¢ä»»åŠ¡...">
                <button id="clearFilters" class="btn-secondary">æ¸…é™¤ç­›é€‰</button>
            </div>

            <!-- ä»»åŠ¡ç»Ÿè®¡ -->
            <div class="task-stats">
                <span>æ€»è®¡: <strong id="totalTasks">0</strong> ä¸ªä»»åŠ¡</span>
                <span>å·²å®Œæˆ: <strong id="completedTasks">0</strong> ä¸ª</span>
                <span>å¾…å®Œæˆ: <strong id="pendingTasks">0</strong> ä¸ª</span>
                <button id="exportBtn" class="btn-secondary">å¯¼å‡ºJSON</button>
                <button id="summaryBtn" class="btn-ai">AIæ€»ç»“</button>
            </div>

            <!-- è¿›åº¦å›¾è¡¨ -->
            <div class="progress-chart" id="progressChart" style="display: none;">
                <canvas id="taskChart" width="400" height="200"></canvas>
            </div>

            <!-- ä»»åŠ¡åˆ—è¡¨ -->
            <div class="task-list" id="taskList">
                <!-- ä»»åŠ¡é¡¹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                <div class="empty-state" id="emptyState">
                    <p>ğŸ‰ æš‚æ— å¾…åŠäº‹é¡¹ï¼Œæ·»åŠ ä¸€ä¸ªä»»åŠ¡å¼€å§‹å§ï¼</p>
                </div>
            </div>

            <!-- åˆ†é¡µæ§åˆ¶ -->
            <div class="pagination" id="pagination" style="display: none;">
                <button id="prevPage" class="btn-secondary">ä¸Šä¸€é¡µ</button>
                <span id="pageInfo">ç¬¬ 1 é¡µ</span>
                <button id="nextPage" class="btn-secondary">ä¸‹ä¸€é¡µ</button>
            </div>

            <!-- AIæ€»ç»“åŒºåŸŸ -->
            <div class="summary-section" id="summarySection" style="display: none;">
                <div class="summary-header">
                    <h3>ğŸ¤– AIä»»åŠ¡åˆ†æ</h3>
                    <button id="closeSummaryBtn" class="btn-close">Ã—</button>
                </div>
                <div class="summary-content" id="summaryContent">
                    <!-- AIæ€»ç»“å†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
                <div class="summary-loading" id="summaryLoading" style="display: none;">
                    <p>AIæ­£åœ¨åˆ†ææ‚¨çš„ä»»åŠ¡...</p>
                </div>
                <div class="summary-error" id="summaryError" style="display: none;">
                    <p>æ€»ç»“ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•</p>
                </div>
            </div>
        </main>

        <footer class="footer">
            <p>ToDoListåº”ç”¨ &copy; 2024</p>
        </footer>
    </div>

    <script>
        class ToDoApp {
            constructor() {
                this.baseURL = 'http://localhost:5000/api';
                this.tasks = [];
                this.currentPage = 1;
                this.tasksPerPage = 10;
                this.filteredTasks = [];
                
                this.initializeElements();
                this.bindEvents();
                this.loadTasks();
                this.loadTheme(); // åŠ è½½ä¿å­˜çš„ä¸»é¢˜
            }

            initializeElements() {
                // è¾“å…¥å…ƒç´ 
                this.taskInput = document.getElementById('taskInput');
                this.taskPriority = document.getElementById('taskPriority');
                this.taskDueDate = document.getElementById('taskDueDate');
                this.taskTags = document.getElementById('taskTags');
                
                // æŒ‰é’®å…ƒç´ 
                this.addTaskBtn = document.getElementById('addTaskBtn');
                this.themeToggle = document.getElementById('themeToggle');
                this.exportBtn = document.getElementById('exportBtn');
                this.summaryBtn = document.getElementById('summaryBtn');
                this.clearFilters = document.getElementById('clearFilters');
                this.prevPage = document.getElementById('prevPage');
                this.nextPage = document.getElementById('nextPage');
                this.closeSummaryBtn = document.getElementById('closeSummaryBtn');
                
                // ç­›é€‰å…ƒç´ 
                this.filterStatus = document.getElementById('filterStatus');
                this.filterPriority = document.getElementById('filterPriority');
                this.searchInput = document.getElementById('searchInput');
                
                // æ˜¾ç¤ºå…ƒç´ 
                this.taskList = document.getElementById('taskList');
                this.emptyState = document.getElementById('emptyState');
                this.pagination = document.getElementById('pagination');
                this.pageInfo = document.getElementById('pageInfo');
                this.totalTasks = document.getElementById('totalTasks');
                this.completedTasks = document.getElementById('completedTasks');
                this.pendingTasks = document.getElementById('pendingTasks');
                
                // AIæ€»ç»“å…ƒç´ 
                this.summarySection = document.getElementById('summarySection');
                this.summaryContent = document.getElementById('summaryContent');
                this.summaryLoading = document.getElementById('summaryLoading');
                this.summaryError = document.getElementById('summaryError');
            }

            bindEvents() {
                // ä»»åŠ¡æ“ä½œ
                this.addTaskBtn.addEventListener('click', () => this.addTask());
                this.taskInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.addTask();
                });

                // ç­›é€‰å’Œæœç´¢
                this.filterStatus.addEventListener('change', () => this.applyFilters());
                this.filterPriority.addEventListener('change', () => this.applyFilters());
                this.searchInput.addEventListener('input', (e) => this.searchTasks(e.target.value));
                this.clearFilters.addEventListener('click', () => this.clearAllFilters());

                // åˆ†é¡µ
                this.prevPage.addEventListener('click', () => this.previousPage());
                this.nextPage.addEventListener('click', () => this.nextPage());

                // å…¶ä»–åŠŸèƒ½
                this.themeToggle.addEventListener('click', () => this.toggleTheme());
                this.exportBtn.addEventListener('click', () => this.exportTasks());
                this.summaryBtn.addEventListener('click', () => this.generateSummary());
                this.closeSummaryBtn.addEventListener('click', () => this.hideSummary());
            }

            async addTask() {
                const title = this.taskInput.value.trim();
                const priority = this.taskPriority.value;
                const dueDate = this.taskDueDate.value;
                const tags = this.taskTags.value;

                if (!title) {
                    this.showError('è¯·è¾“å…¥ä»»åŠ¡å†…å®¹');
                    return;
                }

                try {
                    const taskData = {
                        title,
                        priority,
                        due_date: dueDate || null,
                        tags: tags || null
                    };

                    const response = await fetch(`${this.baseURL}/tasks`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(taskData)
                    });

                    if (!response.ok) {
                        throw new Error('æ·»åŠ ä»»åŠ¡å¤±è´¥');
                    }

                    // æ¸…ç©ºè¾“å…¥æ¡†
                    this.taskInput.value = '';
                    this.taskDueDate.value = '';
                    this.taskTags.value = '';
                    this.taskPriority.value = 'medium';

                    // é‡æ–°åŠ è½½ä»»åŠ¡
                    await this.loadTasks();
                    this.showSuccess('ä»»åŠ¡æ·»åŠ æˆåŠŸ');

                } catch (error) {
                    console.error('æ·»åŠ ä»»åŠ¡é”™è¯¯:', error);
                    this.showError('æ·»åŠ ä»»åŠ¡å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            }

            async loadTasks() {
                try {
                    const response = await fetch(`${this.baseURL}/tasks`);
                    if (!response.ok) {
                        throw new Error('è·å–ä»»åŠ¡å¤±è´¥');
                    }
                    this.tasks = await response.json();
                    this.applyFilters();
                } catch (error) {
                    console.error('åŠ è½½ä»»åŠ¡é”™è¯¯:', error);
                    this.showError('åŠ è½½ä»»åŠ¡å¤±è´¥');
                }
            }

            async getAllTasks() {
                try {
                    const response = await fetch(`${this.baseURL}/tasks`);
                    if (!response.ok) {
                        throw new Error('è·å–ä»»åŠ¡å¤±è´¥');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('è·å–æ‰€æœ‰ä»»åŠ¡é”™è¯¯:', error);
                    this.showError('è·å–ä»»åŠ¡å¤±è´¥');
                    return [];
                }
            }

            searchTasks(keyword) {
                if (!keyword.trim()) {
                    this.applyFilters();
                    return;
                }

                const filtered = this.tasks.filter(task => 
                    task.title.toLowerCase().includes(keyword.toLowerCase()) ||
                    (task.tags && task.tags.toLowerCase().includes(keyword.toLowerCase()))
                );
                this.filteredTasks = filtered;
                this.renderTasks();
            }

            applyFilters() {
                const statusFilter = this.filterStatus.value;
                const priorityFilter = this.filterPriority.value;
                const searchKeyword = this.searchInput.value.trim();

                let filteredTasks = this.tasks;

                // æœç´¢ç­›é€‰
                if (searchKeyword) {
                    filteredTasks = filteredTasks.filter(task => 
                        task.title.toLowerCase().includes(searchKeyword.toLowerCase()) ||
                        (task.tags && task.tags.toLowerCase().includes(searchKeyword.toLowerCase()))
                    );
                }

                // çŠ¶æ€ç­›é€‰
                if (statusFilter === 'completed') {
                    filteredTasks = filteredTasks.filter(task => task.completed);
                } else if (statusFilter === 'pending') {
                    filteredTasks = filteredTasks.filter(task => !task.completed);
                }

                // ä¼˜å…ˆçº§ç­›é€‰
                if (priorityFilter !== 'all') {
                    filteredTasks = filteredTasks.filter(task => task.priority === priorityFilter);
                }

                this.filteredTasks = filteredTasks;
                this.currentPage = 1;
                this.renderTasks();
            }

            clearAllFilters() {
                this.filterStatus.value = 'all';
                this.filterPriority.value = 'all';
                this.searchInput.value = '';
                this.loadTasks();
            }

            renderTasks() {
                const startIndex = (this.currentPage - 1) * this.tasksPerPage;
                const endIndex = startIndex + this.tasksPerPage;
                const tasksToShow = this.filteredTasks.slice(startIndex, endIndex);

                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                this.updateStats();

                // æ¸…ç©ºä»»åŠ¡åˆ—è¡¨
                this.taskList.innerHTML = '';

                if (tasksToShow.length === 0) {
                    this.emptyState.style.display = 'block';
                    this.pagination.style.display = 'none';
                    return;
                }

                this.emptyState.style.display = 'none';

                // æ¸²æŸ“ä»»åŠ¡é¡¹
                tasksToShow.forEach(task => {
                    const taskElement = this.createTaskElement(task);
                    this.taskList.appendChild(taskElement);
                });

                // æ›´æ–°åˆ†é¡µ
                this.updatePagination();
            }

            createTaskElement(task) {
                const taskDiv = document.createElement('div');
                taskDiv.className = `task-item ${task.completed ? 'completed' : ''}`;
                taskDiv.innerHTML = `
                    <div class="task-content">
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''}>
                        <span class="task-title">${this.escapeHtml(task.title)}</span>
                        <div class="task-meta">
                            ${task.priority ? `<span class="priority-badge priority-${task.priority}">${this.getPriorityText(task.priority)}</span>` : ''}
                            ${task.due_date ? `<span class="due-date">ğŸ“… ${task.due_date}</span>` : ''}
                            ${task.tags ? `<span class="tags">ğŸ·ï¸ ${this.escapeHtml(task.tags)}</span>` : ''}
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="btn-edit" data-id="${task.id}">ç¼–è¾‘</button>
                        <button class="btn-delete" data-id="${task.id}">åˆ é™¤</button>
                    </div>
                `;

                // ç»‘å®šäº‹ä»¶
                const checkbox = taskDiv.querySelector('.task-checkbox');
                checkbox.addEventListener('change', () => this.toggleTask(task.id));

                const editBtn = taskDiv.querySelector('.btn-edit');
                editBtn.addEventListener('click', () => this.editTask(task));

                const deleteBtn = taskDiv.querySelector('.btn-delete');
                deleteBtn.addEventListener('click', () => this.deleteTask(task.id));

                return taskDiv;
            }

            async toggleTask(taskId) {
                try {
                    const task = this.tasks.find(t => t.id === taskId);
                    const response = await fetch(`${this.baseURL}/tasks/${taskId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            completed: !task.completed
                        })
                    });

                    if (!response.ok) {
                        throw new Error('æ›´æ–°ä»»åŠ¡å¤±è´¥');
                    }

                    await this.loadTasks();
                } catch (error) {
                    console.error('åˆ‡æ¢ä»»åŠ¡çŠ¶æ€é”™è¯¯:', error);
                    this.showError('æ›´æ–°ä»»åŠ¡å¤±è´¥');
                }
            }

            async deleteTask(taskId) {
                if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ')) {
                    return;
                }

                try {
                    const response = await fetch(`${this.baseURL}/tasks/${taskId}`, {
                        method: 'DELETE'
                    });

                    if (!response.ok) {
                        throw new Error('åˆ é™¤ä»»åŠ¡å¤±è´¥');
                    }

                    await this.loadTasks();
                    this.showSuccess('ä»»åŠ¡åˆ é™¤æˆåŠŸ');
                } catch (error) {
                    console.error('åˆ é™¤ä»»åŠ¡é”™è¯¯:', error);
                    this.showError('åˆ é™¤ä»»åŠ¡å¤±è´¥');
                }
            }

            editTask(task) {
                const newTitle = prompt('ç¼–è¾‘ä»»åŠ¡:', task.title);
                if (newTitle !== null && newTitle.trim() !== '') {
                    this.updateTask(task.id, { title: newTitle.trim() });
                }
            }

            async updateTask(taskId, updates) {
                try {
                    const response = await fetch(`${this.baseURL}/tasks/${taskId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(updates)
                    });

                    if (!response.ok) {
                        throw new Error('æ›´æ–°ä»»åŠ¡å¤±è´¥');
                    }

                    await this.loadTasks();
                    this.showSuccess('ä»»åŠ¡æ›´æ–°æˆåŠŸ');
                } catch (error) {
                    console.error('æ›´æ–°ä»»åŠ¡é”™è¯¯:', error);
                    this.showError('æ›´æ–°ä»»åŠ¡å¤±è´¥');
                }
            }

            updateStats() {
                const total = this.filteredTasks.length;
                const completed = this.filteredTasks.filter(task => task.completed).length;
                const pending = total - completed;

                this.totalTasks.textContent = total;
                this.completedTasks.textContent = completed;
                this.pendingTasks.textContent = pending;
            }

            updatePagination() {
                const totalPages = Math.ceil(this.filteredTasks.length / this.tasksPerPage);
                
                if (totalPages <= 1) {
                    this.pagination.style.display = 'none';
                    return;
                }

                this.pagination.style.display = 'flex';
                this.pageInfo.textContent = `ç¬¬ ${this.currentPage} é¡µï¼Œå…± ${totalPages} é¡µ`;

                this.prevPage.disabled = this.currentPage === 1;
                this.nextPage.disabled = this.currentPage === totalPages;
            }

            previousPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.renderTasks();
                }
            }

            nextPage() {
                const totalPages = Math.ceil(this.filteredTasks.length / this.tasksPerPage);
                if (this.currentPage < totalPages) {
                    this.currentPage++;
                    this.renderTasks();
                }
            }

            async generateSummary() {
                this.showSummaryLoading();
                try {
                    const response = await fetch(`${this.baseURL}/tasks/summary`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `ç”Ÿæˆæ€»ç»“å¤±è´¥! çŠ¶æ€: ${response.status}`);
                    }

                    const result = await response.json();
                    this.showSummary(result.summary);
                    this.showSuccess('AIæ€»ç»“ç”ŸæˆæˆåŠŸ');
                    
                } catch (error) {
                    console.error('ç”ŸæˆAIæ€»ç»“å¤±è´¥:', error);
                    this.showError(error.message || 'ç”ŸæˆAIæ€»ç»“å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                } finally {
                    this.showLoading(false);
                }
            }

            showSummaryLoading() {
                this.summarySection.style.display = 'block';
                this.summaryContent.style.display = 'none';
                this.summaryLoading.style.display = 'block';
                this.summaryError.style.display = 'none';
            }

            showSummary(content) {
                this.summarySection.style.display = 'block';
                this.summaryLoading.style.display = 'none';
                this.summaryError.style.display = 'none';
                this.summaryContent.style.display = 'block';
                this.summaryContent.innerHTML = `<p>${this.escapeHtml(content)}</p>`;
            }

            showSummaryError() {
                this.summarySection.style.display = 'block';
                this.summaryLoading.style.display = 'none';
                this.summaryContent.style.display = 'none';
                this.summaryError.style.display = 'block';
            }

            hideSummary() {
                this.summarySection.style.display = 'none';
            }

            async exportTasks() {
                const tasks = await this.getAllTasks();
                const dataStr = JSON.stringify(tasks, null, 2);
                const dataBlob= new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `todolist-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                this.showSuccess('ä»»åŠ¡å·²å¯¼å‡º');
            }

            toggleTheme() {
                const body = document.body;
                const currentTheme = body.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                body.setAttribute('data-theme', newTheme);
                
                // æ›´æ–°æŒ‰é’®æ–‡æœ¬
                this.themeToggle.textContent = newTheme === 'dark' ? 'â˜€ï¸ åˆ‡æ¢äº®è‰²' : 'ğŸŒ™ åˆ‡æ¢æš—è‰²';
                
                // ä¿å­˜ä¸»é¢˜åå¥½åˆ°æœ¬åœ°å­˜å‚¨
                localStorage.setItem('theme', newTheme);
            }

            loadTheme() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.body.setAttribute('data-theme', savedTheme);
                
                this.themeToggle.textContent = savedTheme === 'dark' ? 'â˜€ï¸ åˆ‡æ¢äº®è‰²' : 'ğŸŒ™ åˆ‡æ¢æš—è‰²';
            }

            showError(message) {
                this.showNotification(message, 'error');
            }

            showSuccess(message) {
                this.showNotification(message, 'success');
            }

            showNotification(message, type) {
                // åˆ›å»ºé€šçŸ¥å…ƒç´ 
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;

                // æ·»åŠ åˆ°é¡µé¢
                document.body.appendChild(notification);

                // è‡ªåŠ¨ç§»é™¤
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            getPriorityText(priority) {
                const priorityMap = {
                    'low': 'ä½ä¼˜å…ˆçº§',
                    'medium': 'ä¸­ä¼˜å…ˆçº§',
                    'high': 'é«˜ä¼˜å…ˆçº§'
                };
                return priorityMap[priority] || priority;
            }

            showLoading(show) {
                // å¯ä»¥æ·»åŠ å…¨å±€åŠ è½½çŠ¶æ€æ˜¾ç¤º
                if (show) {
                    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                } else {
                    // éšè—åŠ è½½çŠ¶æ€
                }
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            new ToDoApp();
        });
    </script>
</body>
</html>